# SQHell â€” TryHackMe (Medium) ğŸ§ ğŸ”¥ğŸ—„ï¸

SQHell is not a â€œthrow payloads and prayâ€ box.

This machine marked the **end of my 50-day CTF cycle**, and honestly, it felt like a checkpoint â€” not because of difficulty, but because of **how much thinking it demanded**.

SQHell forces you to go beyond:
- basic login bypasses
- UNION spam
- tool-only mentality

This box teaches **how SQL actually behaves when things get weird**.

---

## Machine Overview ğŸ–¥ï¸ğŸ“Œ

Room Name: SQHell  
Target IP: 10.201.2.233  
Category: Web / SQL Injection  
Difficulty: Medium  

Focus Areas:
- Manual SQL Injection
- SQLi in **non-traditional input vectors**
- Header-based SQL injection
- SQL Inception (nested / self-referencing queries)
- Thinking when UNION stops working

Pure SQLi lab. No distractions.

---

## Preface ğŸ§ 

This wasnâ€™t just about flags.

This box was about:
- getting stuck
- trying things that didnâ€™t work
- reading
- coming back
- understanding *why* something works

If you rush SQHell, you miss the lesson.

---

## Reconnaissance ğŸ”

Initial scanning behaved oddly.

- Nmap didnâ€™t return meaningful results
- Alternative enumeration revealed:
  - HTTP
  - SSH

Given the room name **SQHell**, the attack surface was clearly the **web application**.

SSH was irrelevant.

---

## Web Enumeration ğŸŒ

The application was small:
- ~4â€“6 pages
- Minimal UI
- Clean frontend
- Multiple user-related endpoints

Nothing screamed â€œvulnerableâ€.

But **manual testing of POST parameters** told a different story.

---

## ğŸš© Flag 1 â€” Login SQL Injection

Testing the login form revealed classic SQLi behavior.

Payload used:

admin' OR 1=1#

yaml
Copy code

Result:
- Authentication bypassed
- **Flag 1 retrieved**

This confirmed:
- User input was directly concatenated into SQL queries
- No sanitization, no parameterization

---

## ğŸš© Flag 2 â€” SQL Injection via HTTP Headers

### Hint:
> â€œMake sure to read the terms and conditions ;)â€

Inside Terms & Conditions:
> â€œWe log IP addresses for analytics.â€

That sentence mattered.

---

### Vulnerable Vector

Testing HTTP headers revealed that **X-Forwarded-For** was:
- Logged
- Stored
- Used in database queries
- Not sanitized

Injecting SQL payloads into this header worked.

Result:
- **Flag 2 retrieved via header-based SQL injection**

Lesson:
SQLi doesnâ€™t live only in forms.

---

## ğŸš© Flag 3 â€” Username Availability Check

During registration, the app makes a background request to:

/check-username

yaml
Copy code

This endpoint:
- Takes user input
- Evaluates it directly in a SQL query

Manual testing confirmed SQLi.

Using `sqlmap` here allowed:
- Database enumeration
- Data extraction

Result:
- **Flag 3 retrieved**

---

## ğŸš© Flag 4 â€” SQL Inception (The Hard Part) ğŸŒ€

### Hint:
> â€œWell, dreams, they feel real while weâ€™re in them right?â€

(Inception, 2010)

---

### Discovery

Endpoint identified:

/user?id=1

yaml
Copy code

Confirmed vulnerable.

---

### Enumeration

- `ORDER BY 4` failed â†’ **3 columns**
- UNION payloads workedâ€¦ but only against `information_schema`
- Normal UNION-based extraction failed for real tables

This is where things broke.

---

## What Is SQL Inception? ğŸ§ 

SQL Inception happens when:
- A query references data **within the same database context**
- Queries are layered or nested
- Standard UNION logic fails due to structure

The backend query was **self-referencing**.

This required:
- Understanding query flow
- Crafting nested SQL payloads
- Extracting data from the same execution context

After research, retries, and restructuring queries:

Result:
- **Flag 4 retrieved**

This part is worth revisiting later â€” itâ€™s painful but educational.

---

## ğŸš© Flag 5 â€” Final SQL Injection

Another vulnerable endpoint was identified:

/post?id=

sql
Copy code

Steps:
- Determined column count
- Identified database & table structure

Final payload used:

/post?id=2 AND 1=2
UNION SELECT 1,2,concat(id,flag),4
FROM sqhell_5.flag
LIMIT 0,1-- -

yaml
Copy code

Result:
- **Final flag retrieved**

SQHell completed.

---

## Conclusion ğŸ

SQHell is not about speed.

Itâ€™s about:
- understanding SQL behavior
- testing assumptions
- attacking places people donâ€™t usually look
- thinking when tools stop helping

---

## Key Takeaways ğŸ”‘

- SQLi exists far beyond login forms  
- HTTP headers are dangerous when trusted  
- Not all SQL injections are UNION-friendly  
- SQL Inception is real â€” and painful ğŸ˜„  
- Struggling is part of learning  

---

## ğŸ“¬ Contact & Projects ğŸ‘¨â€ğŸ’»

**Daksh Baweja**  
Email: dakshbaweja20@gmail.com  
GitHub: https://github.com/sudo0xksh  
LinkedIn: https://www.linkedin.com/in/dakshbaweja  

---

## ğŸš€ Deteroid

Deteroid is a community-driven platform for bug bounty hunters  
to share insights, rate programs, and collaborate on real-world findings.

Built to help hackers **hunt smarter, not louder**.

Instagram: https://www.instagram.com/deteroids/

---

## Final Words â˜•

SQHell teaches one honest truth:

> â€œIf SQL was easy,  
> everyone would understand it.â€

Medium box.  
Heavy thinking.  
Worth every minute.
